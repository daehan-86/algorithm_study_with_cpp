# [[11780] 플로이드 2 (gold2)](https://www.acmicpc.net/problem/11780)
## 문제
![image](https://github.com/daehan-86/baekjoon_study_with_cpp/assets/78295295/ef19a866-6e5e-4930-9c4a-cde01b1715c0)

## 입력
![image](https://github.com/daehan-86/baekjoon_study_with_cpp/assets/78295295/ae4d1dd1-bb12-40e7-bbdd-1a4d45a5bf35)

## 출력
![image](https://github.com/daehan-86/baekjoon_study_with_cpp/assets/78295295/a77ffe3a-b2b1-4d18-8329-81c3a6021a98)

## 풀이
이 문제는 플로이드 알고리즘으로 각 노드간 최단 거리를 구하는 문제이다.  
다만 추가로 최단 경로까지 구해야한다.  
플로이드 알고리즘의 특성상 n^3의 시간 복잡도를 갖는데  
최단 거리를 저장하는 메모리에 중간에 들릴 노드까지 저장하여  
나중에 재귀적으로 경로를 구하면 된다. O(n)의 시간으로 경로를 구할 수 있음.  
이때 모든 경로를 구하는것은 O(n^3)의 시간복잡도를 갖는다.

## 코드
```
#include<iostream>
#include<vector>
#define INF 1000000000
using namespace std;
int n, m, a, b, c;
pair<int,int> map[101][101];
vector<pair<int, int>>v[101];
vector<int>res;
void root(int s, int e) {
	int t = map[s][e].second;
	if (t == e) {
		res.push_back(e);
	}
	else {
		root(s, t);
		root(t, e);
	}
}
int main(void) {
	cin.tie(0);
	ios::sync_with_stdio(0);
	cin >> n >> m;
	fill(map[0], map[101], make_pair(INF, 0));
	for (int i = 0; i < m; i++) {
		cin >> a >> b >> c;
		v[a].push_back({ b,c });
		if (map[a][b].first > c) {
			map[a][b] = { c,b };
		}
	}
	for (int k = 1; k <= n; k++) {
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				if (i!=j&&map[i][j].first > map[i][k].first + map[k][j].first) {
					map[i][j].first = map[i][k].first + map[k][j].first;
					map[i][j].second = k;
				}
			}
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			if (map[i][j].first == INF)cout << "0 ";
			else cout << map[i][j].first << " ";
		}
		cout << "\n";
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			if (map[i][j].first == INF) {
				cout << "0\n";
				continue;
			}
			res = vector<int>(1, i);
			root(i, j);
			cout << res.size() << " ";
			for (int o : res) {
				cout << o << " ";
			}
			cout << "\n";
		}
	}
	return 0;
}
```
