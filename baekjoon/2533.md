# [[2533] 사회망 서비스(SNS) (gold3)](https://www.acmicpc.net/problem/2533)
## 문제  
![image](https://github.com/user-attachments/assets/65249a8c-9782-4404-9493-e154f87da2cf)

## 입력
![image](https://github.com/user-attachments/assets/04b168e4-2e29-44e9-b1a6-74c52783a69e)

## 출력
![image](https://github.com/user-attachments/assets/63b8dc04-687c-4f43-8403-921ffdcac20b)

## 풀이
이 문제는 트리에서의 dp문제로  
단순히 트리로된 구조에서 어떻게 메모이제이션을 구현하는지가 관건이였다.  
0노드와 1이 이어진 구조를 억지로 만들고  
모든 트리를 순회하도록 만들면 아무 문제없이 구현이 가능하다.  
## 코드
```cpp
#include<iostream>
#include<vector>
#define ma 1000001
#define INF 2147483647
using namespace std;
int n, a, b;
int cache[ma][2];
bool visit[ma];
vector<int>v[ma];
int dp(int x, int p) {
	int& ret = cache[x][p];
	if (ret != -1) return ret;
	visit[x] = 1;
	ret = p;
	for (int o : v[x]) {
		if (!visit[o]) {
			if (p) ret += min(dp(o, 0), dp(o, 1));
			else ret += dp(o, 1);
		}
	}
	visit[x] = 0;
	return ret;
}
int main(void) {
	cin.tie(0);
	ios::sync_with_stdio(0);
	cin >> n;
	v[0].push_back(1);
	for (int i = 0; i < n - 1; i++) {
		cin >> a >> b;
		v[a].push_back(b);
		v[b].push_back(a);
	}
	fill(cache[0], cache[ma], -1);
	cout << dp(0, 1) - 1;
	return 0;
}
```
