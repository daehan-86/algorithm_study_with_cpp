# [[25308] 방사형 그래프 (gold4)](https://www.acmicpc.net/problem/25308)
## 문제
![image](https://github.com/daehan-86/baekjoon_study_with_cpp/assets/78295295/67003b15-6955-4385-a3e2-024a89840e54)

## 입력
![image](https://github.com/daehan-86/baekjoon_study_with_cpp/assets/78295295/d2ff127b-992c-45dc-8f2d-a60bb5d40d47)

## 출력
![image](https://github.com/daehan-86/baekjoon_study_with_cpp/assets/78295295/c49151ce-5815-4fe5-a719-a65438b6a57c)

## 풀이
이 문제는 처음에 ccw알고리즘을 이용한 문제인 줄 알았는데  
그렇게 풀면 풀리긴 하겠지만 계산시간이 오래 걸릴 것이다.  
모든 방향에 대해 다 같은 각도를 가지므로 전부 0도, 45도, 90도 일때만  
생각해서 풀면 빠르게 풀릴 것이다.  

이 문제는 티어에 비해 상당히 오래 걸렸는데 재귀를 돌며 맨 마지막에  
기존에 있던 0번째 1번째와 7번째, 0번째 7번째 6번째 이 두개를 비교안해줘서 계속 틀렸다.  

## 코드
```
#include<iostream>
#include<vector>
#include<cmath>
using namespace std;
vector<int>v(8),b(8);
bool visit[8];
bool able(int n1, int n2, int n3) {
	double k = (double)b[n2] / sqrt(2.0);
	double t = (double)(-b[n3]) * k / b[n1] + b[n3];
	if (k >= t) return 1;
	else return 0;
}
int dp(int d) {
	if (d == 8) {
		if (able(7, 0, 1) && able(6, 7, 0)) return 1;
		else return 0;
	}
	int ret = 0;
	for (int i = 0; i < 8; i++) {
		if (!visit[i]) {
			visit[i] = 1;
			b[d] = v[i];
			if (d < 2 || able(d,d-1,d-2)) {
				ret+=dp(d + 1);
			}
			visit[i] = 0;
		}
	}
	return ret;
}
int main(void) {
	cin.tie(0);
	ios::sync_with_stdio(0);
	for (int i = 0; i < 8; i++) {
		cin >> v[i];
	}
	cout<<dp(0);
	return 0;
}
```
