# [[11758] CCW (gold5)](https://www.acmicpc.net/problem/11758)
## 문제
![image](https://github.com/daehan-86/baekjoon_study_with_cpp/assets/78295295/e682d8df-67d3-4b19-bd4e-cfc078128ca6)

## 입력
![image](https://github.com/daehan-86/baekjoon_study_with_cpp/assets/78295295/0f40ae80-ba4e-4522-9c94-ea77103e0e37)

## 출력
![image](https://github.com/daehan-86/baekjoon_study_with_cpp/assets/78295295/5c57dc76-f446-4152-adbe-b98063593c78)

## 풀이
이 문제는 CCW알고리즘의 아주 기초문제이다.  
CCW는 세점이 시계방향인지 직선인지 반시계인지 알려주는 함수이다.  
만약 CCW알고리즘의 리턴값이 0보다 크면 반시계  
0보다 작으면 시계  
0이면 직선이다.  
알고리즘은 21313121만 외우면 된다.((x2-x1)\*(y3-y1)-(x3-x1)*(y2-y1))
## 코드
```cpp
#include<iostream>
using namespace std;
struct point {
	int x, y;
};
int a, b;
int ccw(point a, point b, point c) {
	return (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);
}
int main(void) {
	cin.tie(0);
	ios::sync_with_stdio(0);
	point p[3];
	for (int i = 0; i < 3; i++) {
		cin >> p[i].x >> p[i].y;
	}
	int k = ccw(p[0], p[1], p[2]);
	if (k > 0) cout << "1";
	else if (k < 0) cout << "-1";
	else cout << "0";
	return 0;
}
```
