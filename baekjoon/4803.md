# [[4803] 트리 (gold4)](https://www.acmicpc.net/problem/4803)
## 문제
![image](https://github.com/daehan-86/baekjoon_study_with_cpp/assets/78295295/ab6cfe7d-538b-47c6-a85e-307a2c24f1c6)

## 입력
![image](https://github.com/daehan-86/baekjoon_study_with_cpp/assets/78295295/5710f557-8da4-43f2-af99-9039c497d5e1)

## 출력
![image](https://github.com/daehan-86/baekjoon_study_with_cpp/assets/78295295/7599f77d-4416-4ae8-b0b1-a15bfb5b0d38)

## 풀이
이 문제는 간선을 입력받아 사이클이 존재하는지 확인후 트리의 개수를 세는 문제이다.  
반복문으로 각 노드들을 순회하며 기존에 방문한 노드일 경우 건너 뛴다.  
이후 노드에서 출발하여 재귀함수를 돌며 사이클이 존재하는지 확인한다.  
없을 경우 tree개수 +1을 해준다.  

## 코드
```
#include<iostream>
#include<vector>
using namespace std;
int n, m, a, b;
vector<int>*v;
bool visit[501];
bool dp(int x, int p) {
	bool state = 1;
	for (auto o : v[x]) {
		if (o == p) continue;
		if (!visit[o]) {
			visit[o] = 1;
			if (!dp(o,x))state = 0;
		}
		else {
			state = 0;
		}
	}
	return state;
}
int main(void) {
	cin.tie(0);
	ios::sync_with_stdio(0);
	int t = 0;
	while (1) {
		t++;
		cin >> n >> m;
		if (!n && !m)break;
		v = new vector<int>[n + 1];
		fill(visit, visit + 501, 0);
		for (int i = 0; i < m; i++) {
			cin >> a >> b;
			v[a].push_back(b);
			v[b].push_back(a);
		}
		int cnt = 0;
		for (int i = 1; i <= n; i++) {
			if (!visit[i]) {
				cnt++;
				if (!dp(i, 0)) {
					cnt--;
				}
			}
		}
		cout << "Case " << t << ": ";
		if (!cnt) cout << "No trees.\n";
		else if (cnt == 1) cout << "There is one tree.\n";
		else cout << "A forest of " << cnt << " trees.\n";
		delete[]v;
	}
	return 0;
}
```
