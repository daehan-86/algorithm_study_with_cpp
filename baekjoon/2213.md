# [[2213] 트리의 독립집합 (gold1)](https://www.acmicpc.net/problem/2213)
## 문제
![image](https://github.com/user-attachments/assets/a0d17a43-6c51-4de9-9fe2-53c200e9d128)

## 입력
![image](https://github.com/user-attachments/assets/6e8383d0-514f-4d63-8c75-8cfb93c845c6)

## 출력
![image](https://github.com/user-attachments/assets/747d51bd-d75d-4686-b7e7-120645be73fe)

## 풀이
이 문제는 트리에서의 dp 문제이다.  
단순히 트리를 순회하며 도착한 노드가 포함되는지 안되는지를 나누어서  
약간 배낭문제처럼 풀면된다.  
하지만 dp최적화인 경로추적 방법을 떠올리는게 까다로웠다.  
cache에 저장된 정보를 가지고 포함되는지 안되는지만 판단하면 된다.  
## 코드
```cpp
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int n, w[10001], a, b;
int cache[10001][2];
bool visit[10001];
vector<int>v[10001], res;
int dp(int x,bool p) {
	int& ret = cache[x][p];
	if (ret != -1) return ret;
	ret = 0;
	visit[x] = 1;
	for (int o : v[x]) {
		if (!visit[o]) {
			if (p) ret += dp(o, 0);
			else ret += max(dp(o, 0), dp(o, 1));
		}
	}
	visit[x] = 0;
	if(p) ret += w[x];
	return ret;
}
void find_res(int x, bool p) {
	visit[x] = 1;
	if (p) res.push_back(x);
	for (int o : v[x]) {
		if (!visit[o]) {
			if (p) {
				find_res(o, 0);
			}
			else {
				find_res(o, cache[o][0] < cache[o][1]);
			}
		}
	}
	visit[x] = 0;
}
int main(void) {
	cin.tie(0);
	ios::sync_with_stdio(0);
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> w[i];
	v[0].push_back(1);
	while (cin >> a >> b) {
		v[a].push_back(b);
		v[b].push_back(a);
	}
	fill(cache[0], cache[10001], -1);
	int k = dp(0, 0);
	cout << k << "\n";
	find_res(0, 0);
	sort(res.begin(), res.end());
	for (int o : res) cout << o << " ";
	return 0;
}
```
