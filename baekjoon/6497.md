# [[6497] 전력난 (gold4)](https://www.acmicpc.net/problem/6497)
## 문제
![image](https://github.com/user-attachments/assets/4c9c4a6d-40cf-42af-838e-9bbbaba000bf)

## 입력
![image](https://github.com/user-attachments/assets/f3343da6-13fa-467e-add2-08babffcb0a1)

## 출력
![image](https://github.com/user-attachments/assets/87459c7b-1bd3-471b-a10d-515916898eca)

## 풀이
이 문제는 MST(최소스패닝트리) 문제이고, 일반적인 크루스칼 알고리즘으로 풀 수 있다.  

## 코드
```cpp
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
typedef pair<int, pair<int, int>> p;
int n, m,a,b,c, par[200001];
int getpar(int x) {
	if (x == par[x])return x;
	else return par[x] = getpar(par[x]);
}
void link(int a, int b) {
	a = getpar(a);
	b = getpar(b);
	if (a != b) par[b] = a;
}
int main(void) {
	cin.tie(0);
	ios::sync_with_stdio(0);
	while (1) {
		cin >> n >> m;
		if (!n)break;
		vector<p>v;
		int res = 0;
		int cnt = 0;
		for (int i = 0; i < n; i++) par[i] = i;
		for (int i = 0; i < m; i++) {
			cin >> a >> b >> c;
			v.push_back({ c,{a,b} });
			res += c;
		}
		sort(v.begin(), v.end());
		for (p o : v) {
			if (getpar(o.second.first) != getpar(o.second.second)) {
				link(o.second.first, o.second.second);
				res-=o.first;
				cnt++;
			}
			if (cnt == n - 1) break;
		}
		cout << res << "\n";
	}

	return 0;
}
```
