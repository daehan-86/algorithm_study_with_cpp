# [[17472] 다리 만들기 2 (gold1)](https://www.acmicpc.net/problem/17472)
## 문제
문제가 너무 길어서 사이트 참고하기.  
## 풀이
이 문제는 MST(최소스패닝트리) 문제이지만 아주 까다로운 문제이다.  
찾아보니 삼성 기출문제라고 한다.  
딱 문제가 코테에 엄청 나올거같은 문제이다.  
문제 해법은 다음과 같다.  
1. 먼저 BFS로 각 섬에 번호를 부여한다.
2. 각 좌표를 순회(nm)하여 동서남북으로 다른섬과의 거리를 구한다. 총 (MAX(n,m)*nm)
3. 다리 벡터를 정렬한다. (ElogE)
4. MST알고리즘 중 크루스칼 수행 (E)
5. 최종적으로 섬들이 모두 연결됐는지 확인 (I) - 섬개수순회  
## 코드
```cpp
#include<iostream>
#include<queue>
#include<algorithm>
#include<vector>
using namespace std;
typedef pair<int, int> ii;
typedef pair<int, ii> p;
int n, m, map[11][11], dir[4][2] = { {1,0},{-1,0},{0,1},{0,-1} }, par[11], res;
queue<ii>q;
vector<p> v;
int getpar(int x) {
	if (x == par[x])return x;
	else return par[x] = getpar(par[x]);
}
void link(int a, int b) {
	a = getpar(a);
	b = getpar(b);
	if (a != b) par[b] = a;
}
bool inner(int x, int y) {
	if (x >= 0 && x < n && y >= 0 && y < m)return 1;
	else return 0;
}
int main(void) {
	cin.tie(0);
	ios::sync_with_stdio(0);
	cin >> n >> m;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			cin >> map[i][j];
			map[i][j]--;
		}
	}
	int cnt = 0;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			if (!map[i][j]) {
				q.push({ i,j });
				cnt++;
				map[i][j] = cnt;
				while (!q.empty()) {
					int x = q.front().first, y = q.front().second;
					q.pop();
					for (int d = 0; d < 4; d++) {
						int dx = x + dir[d][0], dy = y + dir[d][1];
						if (inner(dx, dy) && !map[dx][dy]) {
							map[dx][dy] = cnt;
							q.push({ dx,dy });
						}
					}
				}
			}
		}
	}
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			if (map[i][j] < 0) continue;
			int s = map[i][j];
			for (int d = 0; d < 4; d++) {
				for (int l = 1; l < 10; l++) {
					int dx = i + dir[d][0] * l, dy = j + dir[d][1] * l;
					if (!inner(dx, dy)) break;
					int e = map[dx][dy];
					if (s == e)break;
					if (e != s && e > 0) {
						if (l > 2) v.push_back({ l - 1,{s,e} });
						break;
					}
				}
			}
		}
	}
	for (int i = 0; i <= cnt; i++) par[i] = i;
	int c = 0;
	sort(v.begin(), v.end());
	for (p o : v) {
		if (getpar(o.second.first) != getpar(o.second.second)) {
			link(o.second.first, o.second.second);
			res += o.first;
			c++;
		}
		if (c == cnt - 1) break;
	}
	for (int i = 2; i <= cnt;i++) {
		if (getpar(1) != getpar(i)) {
			cout << "-1";
			return 0;
		}
	}
	cout << res;
	return 0;
}
```
