# [[1774] 우주신과의 교감 (gold3)] (https://www.acmicpc.net/problem/1774)
## 문제
![image](https://github.com/daehan-86/baekjoon_study_with_cpp/assets/78295295/375b93d9-c1c9-49d8-b2b6-8fb66c6929bf)

## 입력
![image](https://github.com/daehan-86/baekjoon_study_with_cpp/assets/78295295/2f7d714b-2bd2-4a60-afdf-bc5c69a2a40f)

## 출력
![image](https://github.com/daehan-86/baekjoon_study_with_cpp/assets/78295295/7c1bb784-b753-4888-9220-0be864b0eb1a)

## 풀이
이 문제는 MST(최소스패닝트리)문제이다.  
다른 문제와 다르게 이 문제는 직접 거리를 구해줘야 하므로 처음에 O(n^2)의 시간이 걸린다.  
n최대가 1000이므로 충분히 가능하다.  
이후 코드는 일반적인 MST를 구현하면 된다.
## 코드
```
#include<iostream>
#include<algorithm>
#include<vector>
#include<cmath>
#define X first
#define Y second
using namespace std;
typedef pair<int, int> ii;
typedef pair<double, ii> p;
vector<p> v;
vector<ii> g;
int n, m, a, b;
double res;
int parents[1001];
bool linked[1001][1001];
int parent(int x) {
	if (parents[x] == x) return x;
	return parents[x] = parent(parents[x]);
}
void link(int a, int b) {
	a = parent(a);
	b = parent(b);
	if (a != b) parents[a] = b;
}
double get_dis(ii a, ii b) {
	return sqrt(pow(a.X - b.X,2) + pow(a.Y - b.Y,2));
}
int main(void) {
	cin.tie(0);
	ios::sync_with_stdio(0);
	int linking = 0;
	cin >> n >> m;
	for (int i = 0; i < 1001; i++)parents[i] = i;
	for (int i = 0; i < n; i++) {
		cin >> a >> b;
		g.push_back({ a,b });
	}
	for (int i = 0; i < m; i++) {
		cin >> a >> b;
		if (parent(a)!=parent(b)) {
			linking++;
			link(a, b);
			linked[min(a, b)][max(a, b)];
		}
	}
	for (int i = 0; i < n; i++) {
		for (int j = i + 1; j < n; j++) {
			if (!linked[i + 1][j + 1]) {
				v.push_back({ get_dis(g[i],g[j]),{i + 1,j + 1} });
			}
		}
	}
	sort(v.begin(), v.end());
	for (auto o:v) {
		double d = o.first;
		if (parent(o.second.first)!=parent(o.second.second)) {
			res += d;
			link(o.second.first, o.second.second);
			linking++;
		}
		if (linking == n - 1) break;
	}
	cout<<fixed;
	cout.precision(2);
	cout << res;
	return 0;
}
```
