# [[1976] 여행 가자 (gold4)](https://www.acmicpc.net/problem/1976)
## 문제
![image](https://github.com/daehan-86/baekjoon_study_with_cpp/assets/78295295/4a5c3c10-73ab-4443-b14c-9576669c21ef)

## 입력
![image](https://github.com/daehan-86/baekjoon_study_with_cpp/assets/78295295/797fbdfc-b397-4d56-934a-4cb311792394)

## 출력
![image](https://github.com/daehan-86/baekjoon_study_with_cpp/assets/78295295/ee729da3-68c3-4387-95aa-de8199713077)

## 풀이
이 문제는 유니온 파인드 알고리즘 문제로  
원래 경로를 물어본다면 상당히 오래걸릴 문제이지만  
갈 수 있는지 없는지만 보면 되는 문제이므로  
집합으로 풀 수 있다.  

## 코드
```cpp
#include<iostream>
using namespace std;
int n, m, a, t, tar[201];
int t_find(int x){
	if (tar[x] == x)return x;
	else return tar[x] = t_find(tar[x]);
}
void link(int a, int b) {
	int x = t_find(a), y = t_find(b);
	if(x!=y) tar[x] = y;
}
int main(void) {
	cin.tie(0);
	ios::sync_with_stdio(0);
	cin >> n >> m;
	for (int i = 1; i <= n; i++)tar[i] = i;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			cin >> a;
			if(a) link(i, j);
		}
	}
	cin >> t;
	bool state = 1;
	for (int i = 0; i < m - 1; i++) {
		cin >> a;
		if (t_find(a) != t_find(t)) {
			state = 0;
			break;
		}
	}
	if (state) cout << "YES";
	else cout << "NO";
	return 0;
}
```
