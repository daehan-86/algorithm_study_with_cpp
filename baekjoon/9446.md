# [[9446] 아이템 제작 (platinum4)](https://www.acmicpc.net/problem/9446)
## 문제
![image](https://github.com/user-attachments/assets/32ede4c5-64d9-4254-8752-2bafdaded3e9)

## 입력
![image](https://github.com/user-attachments/assets/4469980e-a5a8-4f74-b84b-4d80ec03b222)

## 출력
![image](https://github.com/user-attachments/assets/d5ed1d81-c545-43dc-b39c-232716bcd360)

## 풀이
이 문제는 다익스트라 문제로 그래프 구조를 생각해내는게 까다로운 문제이다.  
아이템두개를 주면 하나로 바꿔준다는 부분에서 위상정렬이 떠올랐지만  
그보다 다익스트라가 더 적합했다.  

a b c가 주어졌을 때  
b에서 a 까지 cost(c)가 드는 간선  
c에서 a 까지 cost(b)가 드는 간선  
이렇게 그래프를 구현한다면 쉽게 풀 수 있다.  

또한 고려해야 하는 것이 각 그래프의 cost는 매번 갱신되기에  
간선 추가시 가중치를 넣지 않고 헤당 cost의 인덱스를 넣어 사용할 때 참조하게 구현하면 된다.  

## 코드
```cpp
#include<iostream>
#include<queue>
#include<vector>
#define INF 9223372036854775807
using namespace std;
typedef long long ll;
typedef pair<ll, ll> p;
int n, m, a, b, c;
vector<ll> cost(10001,INF);
vector<p> v[10001];
priority_queue<p> q;

void dijkstra(int start) {
	q.push({ 0,start });
	cost[0] = 0;
	while (!q.empty()) {
		ll d = -q.top().first;
		ll x = q.top().second;
		q.pop();
		if (d > cost[x]) continue;
		for (p o : v[x]) {
			if (!x||cost[o.first] > d + cost[o.second]) {
				cost[o.first] = d + cost[o.second];
				q.push({ -(d + cost[o.second]),o.first });
			}
		}
	}
}

int main(void) {
	cin.tie(0);
	ios::sync_with_stdio(0);
	cin >> n >> m;
	for (int i = 0; i < n; i++) {
		cin >> a;
		cost[i + 1] = a;
		v[0].push_back({ i + 1, i + 1 });
	}
	for (int i = 0; i < m; i++) {
		cin >> a >> b >> c;
		v[b].push_back({ a,c });
		v[c].push_back({ a,b });
	}
	dijkstra(0);
	cout << cost[1] << "\n";
	return 0;
}
```
