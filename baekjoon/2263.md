# [[2263] 트리의 순회 (gold1)](https://www.acmicpc.net/problem/2263)
## 문제
![image](https://github.com/daehan-86/baekjoon_study_with_cpp/assets/78295295/ae4fc1f3-1119-43bd-a77e-9065d8b18228)

## 입력
![image](https://github.com/daehan-86/baekjoon_study_with_cpp/assets/78295295/a3386df0-81ea-4768-ad11-83244cef221c)

## 출력
![image](https://github.com/daehan-86/baekjoon_study_with_cpp/assets/78295295/fb2ef97a-6824-4579-9a67-72dc967b362b)

## 풀이
이 문제는 이전에 풀었던 [1991] 문제와 동일하게 전위 순회, 중위 순회, 후위 순회를 구분하는 문제이다.  
하지만 이 문제는 후위 순회와 중위 순회의 결과를 받아서 전위순회를 추측하는 문제이다.  
  
후위 순회의 특성상 루트가 되는 노드는 맨뒤에 있을 것이고,  
중위 순회 특성상 루트가 되는 노드는 중간에 있을 것이다.  

따라서 전위순회를 추측하기 위해선 후위순회의 맨마지막 노드를 저장후  
중위순회에서 찾은뒤, 앞뒤로 잘라서 또다시 재귀적으로 찾아야 한다.  

이를 구현하기 위해선 분할 정복이 적절하다고 판단함.  

## 코드
```cpp
#include<iostream>
#include<vector>
using namespace std;
int n, a;
vector<int>in, po;
void divi(int is, int ie, int ps, int pe) {
	int x = po[pe], i;
	cout << x << " ";
	for (i = is; i <= ie; i++)
		if (in[i] == x)
			break;
	int cnt = i - is;
	if (is < i)divi(is, i - 1, ps, ps + cnt - 1);
	if (i < ie)divi(i + 1, ie, ps + cnt, pe - 1);
}
int main(void) {
	cin.tie(0);
	ios::sync_with_stdio(0);
	cin >> n;
	for (int i = 0; i < n; i++) {
		cin >> a;
		in.push_back(a);
	}
	for (int i = 0; i < n; i++) {
		cin >> a;
		po.push_back(a);
	}
	divi(0, n - 1, 0, n - 1);
	return 0;
}
```
