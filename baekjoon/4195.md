# [[4195] 친구 네트워크 (gold2)](https://www.acmicpc.net/problem/4195)
## 문제
![image](https://github.com/daehan-86/baekjoon_study_with_cpp/assets/78295295/06560e7f-2904-4ce5-b92f-5bd448922f2f)

## 입력
![image](https://github.com/daehan-86/baekjoon_study_with_cpp/assets/78295295/af5861c3-f550-44b2-a178-97bfc6397816)

## 출력
![image](https://github.com/daehan-86/baekjoon_study_with_cpp/assets/78295295/1d369a4d-c28f-4945-982b-2ca1b91a6add)

## 풀이
이 문제는 조금 까다롭다.  
다른 유니온 파인드 알고리즘과 다르게 map을 써서 이름을 찾아야한다.  
또한 각 집합의 수를 계속 업데이트 해줘야 하는데 이게 까다롭다.  
pair를 통해 tar배열에 집합의 수와 가르키는 숫자를 저장하여 출력해주면 된다.  

## 코드
```
#include<iostream>
#include<unordered_map>
#include<string>
using namespace std;
int T, n;
pair<int, int> tar[200001];
string s1, s2;
unordered_map<string, int>m;
pair<int,int> t_find(int x) {
	if (tar[x].first == x)return tar[x];
	else return tar[x] = t_find(tar[x].first);
}
int link(int a, int b) {
	pair<int, int> x = t_find(a), y = t_find(b);
	if (x.first != y.first) {
		tar[x.first].first = y.first;
		tar[y.first].second += tar[x.first].second;
	}
	return tar[y.first].second;
}
int main(void) {
	cin.tie(0);
	ios::sync_with_stdio(0);
	cin >> T;
	while (T--) {
		cin >> n;
		int human = 0;
		m.clear();
		for (int i = 0; i < n; i++) {
			cin >> s1 >> s2;
			int a, b;
			if (m.find(s1) != m.end()) {
				a = m[s1];
			}
			else {
				m[s1] = human;
				a = human;
				tar[human] = { human,1 };
				human++;
			}
			if (m.find(s2) != m.end()) {
				b = m[s2];
			}
			else {
				m[s2] = human;
				b = human;
				tar[human] = { human,1 };
				human++;
			}
			cout << link(a, b) << "\n";
		}
	}
	return 0;
}
```
